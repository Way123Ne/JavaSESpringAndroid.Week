输入流和输出流向对于内存设备而言

将外设中的数据读取到内存中：输入
将内存中的数据读取到外设中：输出

字符流的由来：
其实就是：字节流读取文字字节数据后，不直接操作而是先查指定的编码表，获取对应的文字。
在对这个对应的文字进行操作。简单说：字节流+编码表

--------------------------------------------------------------
--------------------------------------------------------------

字节流的两个顶层父类：
1>InputStream   2>OutputStream

字符流的两个顶层父类：
1>Reader   2>Writer

这些体系的多数子类都以父类名作为后缀
而且子类的前缀就是该对象的功能


从熟悉的文字开始讲解字符流
//需求：将一些文字存储到硬盘中的一个文件中
记住：如果要操作文字数据，建议优先考虑字符流
而且要将数据从内存写到硬盘上，要使用字符流中的数出流。Writer
硬盘的数据基本体现是文件。希望找到一个可以操作文件的Writer

找到了FileWriter


//需求：读取一个文本文件。将读取到的字符打印到控制台
同上


作业：将e盘的一个文本文件复制到d盘
分析：
复制原理：
读取e盘文件中的数据
将这些数据写入到d盘中
连读带写

----------------------------------------------------------------
----------------------------------------------------------------

字符流缓冲区：
BufferedWriter
	:newLine();
	
BufferedReader
	:readLine();
	
使用缓冲区复制一个文本文件

---------------------------------------------------------------
---------------------------------------------------------------

装饰设计模式：
	对一组对象的功能进行增强时，就可以使用该模式进行问题的解决
	
装饰和继承都能实现一样的特点：进行功能的扩展增强
	
但是有什么区别？
首先有一个继承体系：
Writer	
	|--TextWriter:用于操作文本
	|--MediaWriter:用于操作媒体
	
想要对操作的动作进行效率的提高
按照面向对象思想，可以通过继承对具体的功能进行功能的扩展
效率提高需要加入缓冲技术

Writer
	|--TextWriter:用于操作文本
		|--BufferTextWriter:加入了缓冲技术操作文本的对象
	|--MediaWriter:用于操作媒体
		|--BufferMediaWriter
		
到这里貌似可以了，但是这样做并不理想
如果这个体系要进行功能的扩展，又多了流对象
那么这个流要提高效率，是不是也要产生子类？是。这时就会发现一味的提高功能，进行的继承，
将导致继承体系越来越臃肿，不够灵活

重新思考这个问题？
既然加入的都是同一种技术--缓冲
前一种是让缓冲和具体的对象向结合
可不可以将缓冲进行单独的封装，哪个对象需要缓冲就将哪个对象和缓冲向关联

class Buffer{
	Buffer(TextWriter w)
	{}
	
	Buffer(MediaWriter w)
	{}
}

class BufferWriter extends Writer{
	BufferWriter(Writer w){
		
	}
}
Writer
	Writer	
	|--TextWriter:用于操作文本
	|--MediaWriter:用于操作媒体
	|--BufferWriter:用于提高效率
	
总结：
	装饰比继承灵活
	
特点：装饰和被装饰得类都必须所属同一个接口或者父类

--------------------------------------------------------------------
--------------------------------------------------------------------

总结：字符流与字节流主要区别：
		字符流操作文本文件，字节流操作媒体文件
		字符流操作较小数据，字节流操作较大文件